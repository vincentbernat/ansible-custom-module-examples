#!/usr/bin/python

DOCUMENTATION = """
---
module: irr_sync.py
short_description: Filter objects to be sent to IRR
options:
  irr:
    description:
      - IRR to target
  mntner:
    description:
      - object to use as a maintainer
  source:
    description:
      - objects to be sent
"""

RETURN = """
objects:
  description: object to be sent for sync through GPG-email
  type: str
  returned: changed
"""

import yaml
import subprocess
import re
import functools

from ansible.module_utils.basic import AnsibleModule
from ansible.errors import AnsibleError


class RPSLObject(object):
    """IRR object with normalization and comparison.

    The original form is kept is in the `raw' attribute.
    """

    def __init__(self, raw):
        normalized = []
        for line in raw.split("\n"):
            mo = re.match(r"(\S+:)\s*(.*)", line)
            name, value = mo.groups()
            normalized.append(f"{name:16}{value}")
        self.raw = "\n".join(normalized)

    def __repr__(self):
        key = self.raw.split('\n')[0].replace(" ", "")
        return f"<Object:{key}>"

    def __str__(self):
        return "\n".join((s.replace(" # Filtered", "")
                          for s in self.raw.split("\n")
                          if not s.startswith((
                                  "created:",
                                  "last-modified:",
                                  "changed:",  # ARIN: date automatically added
                                  "auth:",     # RIPE: filtered
                                  "method:",   # key-cert: autogenerated
                                  "owner:",    # key-cert: autogenerated
                                  "fingerpr:"  # key-cert: autogenerated
                          ))))

    def __eq__(self, other):
        if not isinstance(other, RPSLObject):
            raise NotImplementedError(
                "cannot compare RPSLObject wih something else")
        return str(self) == str(other)


def extract(raw, excluded):
    """Extract objects."""
    # First step, remove comments and unwanted lines
    objects = "\n".join([obj
                         for obj in raw.split("\n")
                         if not obj.startswith((
                                 "#",
                                 "%",
                         ))])
    # Second step, split objects
    objects = [RPSLObject(obj.strip())
               for obj in re.split(r"\n\n+", objects)
               if obj.strip()
               and not obj.startswith(
                   tuple(f"{x}:" for x in excluded))]
    # Last step, put objects in a dict
    objects = {repr(obj): obj
               for obj in objects}
    return objects


def main():
    module_args = dict(
        irr=dict(type='str', required=True),
        mntner=dict(type='str', required=True),
        source=dict(type='path', required=True),
    )

    result = dict(
        changed=False,
    )

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

    irr = module.params['irr']

    # Per-IRR variations:
    # - whois server
    whois = {
        'ARIN': 'rr.arin.net',
        'RIPE': 'whois.ripe.net',
        'APNIC': 'whois.apnic.net'
    }
    # - whois options
    options = {
        'ARIN': ['-r'],
        'RIPE': ['-BrG'],
        'APNIC': ['-BrG']
    }
    # - objects excluded from synchronization
    excluded = ["domain"]
    if irr == "ARIN":
        # ARIN does not return these objects
        excluded.extend([
            "key-cert",
            "mntner",
        ])

    # Grab existing objects
    args = ["-h", whois[irr],
            "-s", irr,
            *options[irr],
            "-i", "mnt-by",
            module.params['mntner']]
    proc = subprocess.run(["whois", *args], capture_output=True)
    if proc.returncode != 0:
        raise AnsibleError(
            f"unable to query whois: {args}")
    got = extract(proc.stdout.decode('ascii'), excluded)

    with open(module.params['source']) as f:
        source = f.read()
    wanted = extract(source, excluded)

    if got != wanted:
        result['changed'] = True
        if module._diff:
            result['diff'] = [
                dict(before_header=k,
                     after_header=k,
                     before=str(got.get(k, "")),
                     after=str(wanted.get(k, "")))
                for k in set((*wanted.keys(), *got.keys()))
                if k not in wanted or k not in got or wanted[k] != got[k]]

        # We send all source objects and deleted objects.
        deleted_mark = f"{'delete:':16}deleted by CMDB"
        deleted = "\n\n".join([f"{got[k].raw}\n{deleted_mark}"
                               for k in got
                               if k not in wanted])
        result['objects'] = f"{source}\n\n{deleted}"

    module.exit_json(**result)


if __name__ == '__main__':
    main()
